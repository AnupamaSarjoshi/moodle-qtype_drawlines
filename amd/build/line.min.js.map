{"version":3,"file":"line.min.js","sources":["../src/line.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/* eslint max-depth: [\"error\", 8] */\n\n/**\n * Library of classes for handling lines and points.\n *\n * These classes can represent Points and line, let you alter them\n * and can give you an SVG representation.\n *\n * @module     qtype_drawlines/line\n * @copyright  2024 The Open University\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine(function() {\n\n    \"use strict\";\n\n    /**\n     * A point, with x and y coordinates.\n     *\n     * @param {int} x centre X.\n     * @param {int} y centre Y.\n     * @constructor\n     */\n    function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Standard toString method.\n     *\n     * @returns {string} \"x;y\";\n     */\n    Point.prototype.toString = function() {\n        return this.x + ',' + this.y;\n    };\n\n    /**\n     * Move a point\n     *\n     * @param {int} dx x offset\n     * @param {int} dy y offset\n     */\n    Point.prototype.move = function(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n    };\n\n    /**\n     * Return a new point that is a certain position relative to this one.\n     *\n     * @param {(int|Point)} offsetX if a point, offset by these points coordinates, else and int x offset.\n     * @param {int} [offsetY] used if offsetX is an int, the corresponding y offset.\n     * @return {Point} the new point.\n     */\n    Point.prototype.offset = function(offsetX, offsetY) {\n        if (offsetX instanceof Point) {\n            offsetY = offsetX.y;\n            offsetX = offsetX.x;\n        }\n        return new Point(this.x + offsetX, this.y + offsetY);\n    };\n\n    /**\n     * Make a point from the string representation.\n     *\n     * @param {String} coordinates \"x,y\".\n     * @return {Point} the point. Throws an exception if input is not valid.\n     */\n    Point.parse = function(coordinates) {\n        var bits = coordinates.split(',');\n        if (bits.length !== 2) {\n            throw new Error(coordinates + ' is not a valid point');\n        }\n        return new Point(Math.round(bits[0]), Math.round(bits[1]));\n    };\n\n    /**\n     * Line constructor. Class to represent the different types of drop zone shapes.\n     *\n     * @param {int} [x1] centre X1.\n     * @param {int} [y1] centre Y1.\n     * @param {int} [startRadius] startRadius.\n     * @param {int} [x2] centre X2.\n     * @param {int} [y2] centre Y2.\n     * @param {int} [endRadius] endRadius.\n     * @param {String} [lineType] Line type.\n     * @param {String} [labelstart] start label of a line.\n     * @param {String} [labelmiddle] middle label of a line.\n     * @param {String} [labelend] end label of a line.\n     * @constructor\n     */\n    function Line(x1, y1, startRadius, x2, y2, endRadius, lineType, labelstart, labelmiddle, labelend) {\n        this.x1 = x1;\n        this.y1 = y1;\n\n        this.x2 = x2;\n        this.y2 = y2;\n\n        this.centre1 = new Point(x1, y1);\n        this.centre2 = new Point(x2, y2);\n\n        this.startRadius = startRadius;\n        this.endRadius = endRadius;\n\n        this.lineType = lineType;\n\n        this.labelstart = labelstart;\n        this.labelmiddle = labelmiddle;\n        this.labelend = labelend;\n    }\n    Line.prototype = new Line();\n\n    /**\n     * Get the type of shape.\n     *\n     * @return {String} 'linesinglearrow', 'linedoublearrows', 'lineinfinite'.\n     */\n    Line.prototype.getType = function() {\n        return this.lineType;\n    };\n\n    /**\n     * Get the string representation of this shape.\n     *\n     * @return {String} coordinates as they need to be typed into the form.\n     */\n    Line.prototype.getCoordinates = function() {\n        return [\n            this.centre1.x + ',' + this.centre1.y + ';' + this.startRadius,\n            this.centre2.x + ',' + this.centre2.y + ';' + this.endRadius\n        ];\n    };\n\n    /**\n     * Create the svg group with line.\n     *\n     * @param {SVGElement} svg the SVG graphic to add this shape to.\n     * @param {int} bgImageWidth\n     * @param {int} bgImageHeight\n     * @return {SVGElement} SVG representation of this shape.\n     */\n    Line.prototype.makeSvg = function(svg, bgImageWidth, bgImageHeight) {\n        addLineArrow(svg);\n        var svgEl = createSvgShapeGroup(svg, 'polyline');\n        this.updateSvg(svgEl, bgImageWidth, bgImageHeight);\n        return svgEl;\n    };\n\n    /**\n     * Update the SVG representation of this shape.\n     *\n     * @param {SVGElement} svgEl the SVG representation of this shape.\n     * @param {int} bgImageWidth\n     * @param {int} bgImageHeight\n     */\n    Line.prototype.updateSvg = function(svgEl, bgImageWidth, bgImageHeight) {\n        // Set line attributes.\n        this.drawLine(svgEl, bgImageWidth, bgImageHeight);\n\n        // Set start and end circle attributes.\n        svgEl.childNodes[1].setAttribute('cx', this.centre1.x);\n        svgEl.childNodes[1].setAttribute('cy', this.centre1.y);\n        svgEl.childNodes[1].setAttribute('r', Math.abs(this.startRadius));\n\n        svgEl.childNodes[2].setAttribute('cx', this.centre2.x);\n        svgEl.childNodes[2].setAttribute('cy', this.centre2.y);\n        svgEl.childNodes[2].setAttribute('r', Math.abs(this.endRadius));\n\n        // If the svg g element is already placed in dropzone, then add the keyboard support.\n        var svgClass = svgEl.getAttribute('class');\n        if (svgClass && svgClass.includes('placed')) {\n            svgEl.childNodes[1].setAttribute('tabindex', '0');\n            svgEl.childNodes[2].setAttribute('tabindex', '0');\n        }\n        this.updateSvgLabels(svgEl, bgImageWidth, bgImageHeight);\n    };\n\n    /**\n     * Update the SVG representation of this shape.\n     *\n     * @param {SVGElement} svgEl the SVG representation of this shape.\n     * @param {int} bgImageWidth\n     * @param {int} bgImageHeight\n     */\n    Line.prototype.updateSvgLabels = function(svgEl, bgImageWidth, bgImageHeight) {\n        // Set start and end label attributes.\n        svgEl.childNodes[3].textContent = this.labelstart;\n        this.adjustTextPosition(svgEl.childNodes[3], this.centre1.x, this.centre1.y,\n            bgImageWidth, bgImageHeight);\n\n        svgEl.childNodes[4].textContent = this.labelmiddle;\n        let middlex = Math.abs((this.centre1.x + this.centre2.x) / 2);\n        let middley = Math.abs((this.centre1.y + this.centre2.y) / 2);\n        this.adjustTextPosition(svgEl.childNodes[4], parseInt(middlex), parseInt(middley), bgImageWidth, bgImageHeight);\n\n        svgEl.childNodes[5].textContent = this.labelend;\n        this.adjustTextPosition(svgEl.childNodes[5], this.centre2.x, this.centre2.y,\n            bgImageWidth, bgImageHeight);\n    };\n\n    /**\n     * Update svg line attributes.\n     *\n     * @param {SVGElement} [svgTextEl] the text node of the SVG.\n     * @param {int} [linex] coordinate of the line.\n     * @param {int} [liney] coordinate of the line.\n     * @param {int} bgImageWidth\n     * @param {int} bgImageHeight\n     */\n    Line.prototype.adjustTextPosition = function(svgTextEl, linex, liney, bgImageWidth, bgImageHeight) {\n        const padding = 20;\n\n        // Text element dimensions.\n        const bbox = svgTextEl.getBBox();\n        const textWidth = bbox.width;\n\n        svgTextEl.setAttribute('x', linex);\n        svgTextEl.setAttribute('y', liney + padding);\n\n        // Recalculate the position of x and y coordinates of text, to make sure the text content is fully displayed.\n        if (linex < textWidth / 2) {\n            svgTextEl.setAttribute('x', Math.abs(parseInt(textWidth / 2)));\n        } else if ((linex + (textWidth / 2)) > bgImageWidth) {\n            svgTextEl.setAttribute('x', Math.abs(parseInt(bgImageWidth - (textWidth / 2))));\n        }\n\n        if (liney + padding > bgImageHeight) {\n            // Adjust if the line is very near to the bottom of the svg.\n            svgTextEl.setAttribute('y', liney - padding);\n        }\n    };\n\n    /**\n     * Update svg line attributes.\n     *\n     * @param {SVGElement} svgEl the SVG representation of the shape.\n     * @param {int} bgImageWidth\n     * @param {int} bgImageHeight\n     */\n    Line.prototype.drawLine = function(svgEl, bgImageWidth, bgImageHeight) {\n        // Set attributes for the polyline.\n        svgEl.childNodes[0].style.stroke = \"#000973\";\n        svgEl.childNodes[0].style['stroke-width'] = \"3\";\n        svgEl.childNodes[0].style['stroke-dasharray'] = \"10,3\";\n\n        var points = this.centre1.x + \",\" + this.centre1.y + \" \" + this.centre2.x + \",\" + this.centre2.y;\n        svgEl.childNodes[0].setAttribute('points', points);\n\n        // Set attributes to display line based on linetype.\n        switch (this.lineType) {\n            case 'linesinglearrow':\n                svgEl.childNodes[0].style['marker-end'] = \"url(#arrow)\";\n                svgEl.childNodes[0].setAttribute('class', 'shape singlearrow');\n                break;\n\n            case 'linedoublearrows':\n                svgEl.childNodes[0].style['marker-start'] = \"url(#arrow)\";\n                svgEl.childNodes[0].style['marker-end'] = \"url(#arrow)\";\n                svgEl.childNodes[0].setAttribute('class', 'shape doublearrows');\n                break;\n\n            case 'lineinfinite':\n                var newCoordinates = this.drawInfiniteLine(svgEl.parentNode, bgImageWidth, bgImageHeight);\n                var infiniteLine = newCoordinates[0] + \",\" + newCoordinates[1] +\n                    \" \" + points + \" \" + newCoordinates[2] + \",\" + newCoordinates[3];\n                svgEl.childNodes[0].setAttribute('points', infiniteLine);\n                svgEl.childNodes[0].setAttribute('class', 'shape infinite');\n                break;\n        }\n    };\n\n    /**\n     * Get the minimum and maximum endpoints of the line to draw an infinite line.\n     *\n     * @param {SVGElement} svg the SVG representation of the shape.\n     * @param {int} bgImageWidth\n     * @param {int} bgImageHeight\n     */\n    Line.prototype.drawInfiniteLine = function(svg, bgImageWidth, bgImageHeight) {\n\n        // Calculate slope\n        const dx = this.centre2.x - this.centre1.x;\n        const dy = this.centre2.y - this.centre1.y;\n\n        // Calculate points far outside the SVG canvas\n        let xMin, yMin, xMax, yMax;\n        if (dx === 0) { // Vertical line\n            xMin = xMax = this.centre1.x;\n            yMin = 0;\n            yMax = bgImageHeight;\n        } else if (dy === 0) { // Horizontal line\n            xMin = 0;\n            xMax = bgImageWidth;\n            yMin = yMax = this.centre1.y;\n        } else {\n            const slope = dy / dx;\n            const intercept = this.centre1.y - slope * this.centre1.x;\n\n            // Find intersection points with SVG canvas borders\n            xMin = -bgImageWidth; // Starting far left\n            yMin = slope * xMin + intercept;\n\n            xMax = 2 * bgImageWidth; // Extending far right\n            yMax = slope * xMax + intercept;\n\n            // Clamp to canvas height bounds\n            if (yMin < 0) {\n                yMin = 0;\n                xMin = (yMin - intercept) / slope;\n            } else if (yMin > bgImageHeight) {\n                yMin = bgImageHeight;\n                xMin = (yMin - intercept) / slope;\n            }\n\n            if (yMax < 0) {\n                yMax = 0;\n                xMax = (yMax - intercept) / slope;\n            } else if (yMax > bgImageHeight) {\n                yMax = bgImageHeight;\n                xMax = (yMax - intercept) / slope;\n            }\n        }\n        return [Math.round(xMin), Math.round(yMin), Math.round(xMax), Math.round(yMax)];\n    };\n\n    /**\n     * Parse the coordinates from the string representation.\n     *\n     * @param {String} startcoordinates \"x1,y1;radius\".\n     * @param {String} endcoordinates \"x1,y1;radius\".\n     * @param {float} ratio .\n     * @return {boolean} True if the coordinates are valid and parsed. Throws an exception if input point is not valid.\n     */\n    Line.prototype.parse = function(startcoordinates, endcoordinates, ratio) {\n        var startcoordinatesbits = startcoordinates.split(';');\n        var endcoordinatesbits = endcoordinates.split(';');\n        this.centre1 = Point.parse(startcoordinatesbits[0]);\n        this.centre2 = Point.parse(endcoordinatesbits[0]);\n        this.centre1.x = this.centre1.x * parseFloat(ratio);\n        this.centre1.y = this.centre1.y * parseFloat(ratio);\n        this.x1 = this.centre1.x * parseFloat(ratio);\n        this.y1 = this.centre1.y * parseFloat(ratio);\n        this.x2 = this.centre2.x * parseFloat(ratio);\n        this.y2 = this.centre2.y * parseFloat(ratio);\n        this.centre2.x = this.centre2.x * parseFloat(ratio);\n        this.centre2.y = this.centre2.y * parseFloat(ratio);\n        this.startRadius = Math.round(startcoordinatesbits[1]) * parseFloat(ratio);\n        this.endRadius = Math.round(endcoordinatesbits[1]) * parseFloat(ratio);\n\n        return true;\n    };\n\n    /**\n     * Move the entire shape by this offset.\n     *\n     * @param {String} whichHandle which circle handle was moved, i.e., startcircle or endcircle.\n     * @param {int} dx x offset.\n     * @param {int} dy y offset.\n     * @param {int} maxX ensure that after editing, the shape lies between 0 and maxX on the x-axis.\n     * @param {int} maxY ensure that after editing, the shape lies between 0 and maxX on the y-axis.\n     */\n    Line.prototype.move = function(whichHandle, dx, dy, maxX, maxY) {\n        if (whichHandle === 'startcircle') {\n            this.centre1.move(dx, dy);\n            if (this.centre1.x < this.startRadius) {\n                this.centre1.x = this.startRadius;\n                this.x1 = this.startRadius;\n            }\n            if (this.centre1.x > maxX - this.startRadius) {\n                this.centre1.x = maxX - this.startRadius;\n                this.x1 = maxX - this.startRadius;\n            }\n            if (this.centre1.y < this.startRadius) {\n                this.centre1.y = this.startRadius;\n                this.y1 = this.startRadius;\n            }\n            if (this.centre1.y > maxY - this.startRadius) {\n                this.centre1.y = maxY - this.startRadius;\n                this.y1 = maxY - this.startRadius;\n            }\n        } else {\n            this.centre2.move(dx, dy);\n            if (this.centre2.x < this.endRadius) {\n                this.centre2.x = this.endRadius;\n                this.x2 = this.endRadius;\n            }\n            if (this.centre2.x > maxX - this.endRadius) {\n                this.centre2.x = maxX - this.endRadius;\n                this.x2 = maxX - this.endRadius;\n            }\n            if (this.centre2.y < this.endRadius) {\n                this.centre2.y = this.endRadius;\n                this.y2 = this.endRadius;\n            }\n            if (this.centre2.y > maxY - this.endRadius) {\n                this.centre2.y = maxY - this.endRadius;\n                this.y2 = maxY - this.endRadius;\n            }\n        }\n    };\n\n    /**\n     * Move the line end points by this offset.\n     *\n     * @param {int} dx x offset.\n     * @param {int} dy y offset.\n     * @param {int} maxX ensure that after editing, the shape lies between 0 and maxX on the x-axis.\n     * @param {int} maxY ensure that after editing, the shape lies between 0 and maxX on the y-axis.\n     */\n    Line.prototype.moveDrags = function(dx, dy, maxX, maxY) {\n        // Move the lines in the dropzones.\n        this.centre1.move(dx, dy);\n        this.centre2.move(dx, dy);\n        if (this.centre1.x < this.startRadius) {\n            this.centre1.x = this.startRadius;\n            this.x1 = this.startRadius;\n        }\n        if (this.centre1.x > maxX - this.startRadius) {\n            this.centre1.x = maxX - this.startRadius;\n            this.x1 = maxX - this.startRadius;\n        }\n        if (this.centre2.x < this.endRadius) {\n            this.centre2.x = this.endRadius;\n            this.x2 = this.endRadius;\n        }\n        if (this.centre2.x > maxX - this.endRadius) {\n            this.centre2.x = maxX - this.endRadius;\n            this.x2 = maxX - this.endRadius;\n        }\n        if (this.centre1.y < this.startRadius) {\n            this.centre1.y = this.startRadius;\n            this.y1 = this.startRadius;\n        }\n        if (this.centre1.y > maxY - this.startRadius) {\n            this.centre1.y = maxY - this.startRadius;\n            this.y1 = maxY - this.startRadius;\n        }\n        if (this.centre2.y < this.endRadius) {\n            this.centre2.y = this.endRadius;\n            this.y2 = this.endRadius;\n        }\n        if (this.centre2.y > maxY - this.endRadius) {\n            this.centre2.y = maxY - this.endRadius;\n            this.y2 = maxY - this.endRadius;\n        }\n    };\n\n    /**\n     * Move the g element between the dropzones and dragHomes.\n     *\n     * @param {String} eventType Whether it's a mouse event or a keyboard event.\n     * @param {SVGElement} selectedElement The element selected for dragging.\n     * @param {SVG} svgDropZones\n     * @param {SVG} svgDragsHome\n     * @param {int|null} dropX Used by mouse events to calculate the svg to which it belongs.\n     * @param {int|null} dropY\n     * @param {int|null} bgImageHeight height of the background image, to decide the position of where to drop the line.\n     * @param {String|null} whichSVG\n     */\n    Line.prototype.addToDropZone = function(eventType, selectedElement, svgDropZones, svgDragsHome,\n            dropX, dropY, bgImageHeight, whichSVG) {\n        let dropzoneNo = selectedElement.getAttribute('data-dropzone-no'),\n            classattributes,\n            dropZone = false;\n        const initiallinespacing = 25,\n            spacingbetweenlines = 50;\n        if (eventType === 'mouse') {\n            dropZone = this.isInsideSVG(svgDragsHome, dropX, dropY);\n        } else {\n            dropZone = (whichSVG === 'DragsSVG');\n        }\n        if (dropZone) {\n            // Append the element to the dropzone SVG.\n            svgDropZones.appendChild(selectedElement);\n            selectedElement.getAttribute('data-dropzone-no');\n\n            // Set tabindex to add keyevents to the circle movehandles.\n            selectedElement.childNodes[1].setAttribute('tabindex', '0');\n            selectedElement.childNodes[2].setAttribute('tabindex', '0');\n\n            // Caluculate the position of line drop.\n            this.centre1.y = bgImageHeight - (2 * this.startRadius);\n            this.y1 = bgImageHeight - (2 * this.startRadius);\n            this.centre2.y = bgImageHeight - (2 * this.endRadius);\n            this.y2 = bgImageHeight - (2 * this.endRadius);\n\n            // Update the class attributes to 'placed' if the line is in the svgDropZone.\n            classattributes = selectedElement.getAttribute('class');\n            classattributes = classattributes.replace('inactive', 'placed');\n            selectedElement.setAttribute('class', classattributes);\n        } else {\n            // Append the element to the draghomes SVG.\n            svgDragsHome.appendChild(selectedElement);\n\n            // We want to drop the lines from the top, depending on the line number.\n            // Calculate the position of line drop.\n            this.centre1.x = 50;\n            this.centre1.y = initiallinespacing + (dropzoneNo * spacingbetweenlines);\n            this.y1 = initiallinespacing + (dropzoneNo * spacingbetweenlines);\n            this.centre2.x = 200;\n            this.centre2.y = initiallinespacing + (dropzoneNo * spacingbetweenlines);\n            this.y2 = initiallinespacing + (dropzoneNo * spacingbetweenlines);\n\n            // Update the class attributes to 'inactive' if the line is in the svg draghome.\n            classattributes = selectedElement.getAttribute('class');\n            classattributes = classattributes.replace('placed', 'inactive');\n            selectedElement.setAttribute('class', classattributes);\n            // Set tabindex = -1, so the circle movehandles aren't focusable when in draghomes svg.\n            selectedElement.childNodes[1].setAttribute('tabindex', '-1');\n            selectedElement.childNodes[2].setAttribute('tabindex', '-1');\n        }\n    };\n\n    /**\n     * Check if the current selected element is in the svg .\n     *\n     * @param {SVGElement} svg Svg element containing the drags.\n     * @param {int} dropX\n     * @param {int} dropY\n     * @return {bool}\n     */\n    Line.prototype.isInsideSVG = function(svg, dropX, dropY) {\n        const rect = svg.getBoundingClientRect();\n        return dropX >= rect.left && dropX <= rect.right && dropY >= rect.top && dropY <= rect.bottom;\n    };\n\n    /**\n     * Move one of the edit handles by this offset.\n     *\n     * @param {String} handleIndex which handle was moved.\n     * @param {int} dx x offset.\n     * @param {int} dy y offset.\n     * @param {int} maxX ensure that after editing, the shape lies between 0 and maxX on the x-axis.\n     * @param {int} maxY ensure that after editing, the shape lies between 0 and maxX on the y-axis.\n     */\n    Line.prototype.edit = function(handleIndex, dx, dy, maxX, maxY) {\n        var limit = 0;\n        if (handleIndex === '0') {\n            this.startRadius += dx;\n            limit = Math.min(this.centre1.x, this.centre1.y, maxX - this.centre1.x, maxY - this.centre1.y);\n            if (this.startRadius > limit) {\n                this.startRadius = limit;\n            }\n            if (this.startRadius < -limit) {\n                this.startRadius = -limit;\n            }\n        } else {\n            this.endRadius += dx;\n            limit = Math.min(this.centre2.x, this.centre2.y, maxX - this.centre2.x, maxY - this.centre2.y);\n            if (this.endRadius > limit) {\n                this.endRadius = limit;\n            }\n            if (this.endRadius < -limit) {\n                this.endRadius = -limit;\n            }\n        }\n    };\n\n    /**\n     * Get the handles that should be offered to edit this shape, or null if not appropriate.\n     *\n     * @return {Object[]} with properties moveHandleStart {Point}, moveHandleEnd {Point} and editHandles {Point[]}.\n     */\n    Line.prototype.getHandlePositions = function() {\n        return {\n            moveHandles: [new Point(this.centre1.x, this.centre1.y), new Point(this.centre2.x, this.centre2.y)],\n            editHandles: [this.centre1.offset(this.startRadius, 0), this.centre2.offset(this.endRadius, 0)]\n        };\n    };\n\n    /**\n     * Update the properties of this shape after a sequence of edits.\n     *\n     * For example make sure the circle radius is positive, of the polygon centre is centred.\n     */\n    Line.prototype.normalizeShape = function() {\n        this.startRadius = Math.abs(this.startRadius);\n        this.endRadius = Math.abs(this.endRadius);\n    };\n\n    /**\n     * Add a new arrow SVG DOM element as a child of svg.\n     *\n     * @param {SVGElement} svg the parent node.\n     */\n     function addLineArrow(svg) {\n        if (svg.getElementsByTagName('defs')[0]) {\n            return;\n        }\n        var svgdefsEl = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'defs');\n        var svgmarkerEl = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'marker');\n        svgmarkerEl.setAttribute('id', 'arrow');\n        svgmarkerEl.setAttribute('viewBox', \"0 0 10 10\");\n        svgmarkerEl.setAttribute('refX', '7');\n        svgmarkerEl.setAttribute('refY', '5');\n        svgmarkerEl.setAttribute('markerWidth', '4');\n        svgmarkerEl.setAttribute('markerHeight', '4');\n        svgmarkerEl.setAttribute('orient', 'auto-start-reverse');\n        var svgPathEl = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');\n        svgPathEl.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n        svgmarkerEl.appendChild(svgPathEl);\n        svgdefsEl.appendChild(svgmarkerEl);\n\n        svg.appendChild(svgdefsEl);\n    }\n\n    /**\n     * Make a new SVG DOM element as a child of svg.\n     *\n     * @param {SVGElement} svg the parent node.\n     * @param {String} tagName the tag name.\n     * @return {SVGElement} the newly created node.\n     */\n    function createSvgElement(svg, tagName) {\n        var svgEl = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', tagName);\n        svg.appendChild(svgEl);\n        return svgEl;\n    }\n\n    /**\n     * Make a group SVG DOM elements containing a polyline of the given linetype as first child,\n     * two circles to mark the allowed radius for grading and text labels for the line.\n     *\n     * @param {SVGElement} svg the parent node.\n     * @param {String} tagName the tag name.\n     * @return {SVGElement} the newly created g element.\n     */\n    function createSvgShapeGroup(svg, tagName) {\n        var svgEl = createSvgElement(svg, 'g');\n        svgEl.setAttribute('tabindex', '0');\n        var lineEl = createSvgElement(svgEl, tagName);\n        lineEl.setAttribute('class', 'shape');\n        var startcircleEl = createSvgElement(svgEl, 'circle');\n        startcircleEl.setAttribute('class', 'startcircle shape');\n        var endcirleEl = createSvgElement(svgEl, 'circle');\n        endcirleEl.setAttribute('class', 'endcircle shape');\n        createSvgElement(svgEl, 'text').setAttribute('class', 'labelstart shapeLabel');\n        createSvgElement(svgEl, 'text').setAttribute('class', 'labelmiddle shapeLabel');\n        createSvgElement(svgEl, 'text').setAttribute('class', 'labelend shapeLabel');\n        return svgEl;\n    }\n\n    /**\n     * @alias module:qtype_drawlines/drawLine\n     */\n    return {\n        /**\n         * A point, with x and y coordinates.\n         *\n         * @param {int} x centre X.\n         * @param {int} y centre Y.\n         * @constructor\n         */\n        Point: Point,\n\n        /**\n         * Line constructor. Class to represent the different types of drop zone shapes.\n         *\n         * @param {int} [x1] centre X1.\n         * @param {int} [y1] centre Y1.\n         * @param {int} [startRadius] startRadius.\n         * @param {int} [x2] centre X2.\n         * @param {int} [y2] centre Y2.\n         * @param {int} [endRadius] endRadius.\n         * @param {String} [lineType] Line type.\n         * @param {String} [labelstart] start label of a line.\n         * @param {String} [labelmiddle] middle label of a line.\n         * @param {String} [labelend] end label of a line.\n         * @constructor\n         */\n        Line: Line,\n\n        /**\n         * Make a new SVG DOM element as a child of svg.\n         *\n         * @param {SVGElement} svg the parent node.\n         * @param {String} tagName the tag name.\n         * @return {SVGElement} the newly created node.\n         */\n        createSvgElement: createSvgElement,\n\n        /**\n         * Make a line of the given type.\n         *\n         * @param {Array} [linecoordinates] in the format (x,y;radius).\n         * @param {String} [lineType] The linetype (e.g., linesinglearrow, linedoublearrows, ...).\n         * @param {Array} [labels] Start, middle and end labels of a line.\n         * @return {Line} the new line.\n         */\n        make: function(linecoordinates, lineType, labels) {\n            // Line coordinates are in the format (x,y;radius).\n            var startcoordinates = linecoordinates[0].split(';');\n            var endcoordinates = linecoordinates[1].split(';');\n            var linestartbits = startcoordinates[0].split(',');\n            var lineendbits = endcoordinates[0].split(',');\n\n            return new Line(parseInt(linestartbits[0]), parseInt(linestartbits[1]), parseInt(startcoordinates[1]),\n                parseInt(lineendbits[0]), parseInt(lineendbits[1]), parseInt(endcoordinates[1]), lineType,\n                labels[0], labels[1], labels[2]);\n        },\n\n        /**\n         * Make a line of the given linetype having similar coordinates and labels as the original type.\n         *\n         * @param {String} lineType the new type of line to make.\n         * @param {line} line the line to copy.\n         * @return {line} the similar line of a different linetype.\n         */\n        getSimilar: function(lineType, line) {\n            return new Line(parseInt(line.x1), parseInt(line.y1), parseInt(line.startRadius),\n                parseInt(line.x2), parseInt(line.y2), parseInt(line.endRadius), lineType,\n                line.labelstart, line.labelmiddle, line.labelend);\n        }\n    };\n});\n"],"names":["define","Point","x","y","Line","x1","y1","startRadius","x2","y2","endRadius","lineType","labelstart","labelmiddle","labelend","centre1","centre2","createSvgElement","svg","tagName","svgEl","ownerDocument","createElementNS","appendChild","prototype","toString","this","move","dx","dy","offset","offsetX","offsetY","parse","coordinates","bits","split","length","Error","Math","round","getType","getCoordinates","makeSvg","bgImageWidth","bgImageHeight","getElementsByTagName","svgdefsEl","svgmarkerEl","setAttribute","svgPathEl","addLineArrow","createSvgShapeGroup","updateSvg","drawLine","childNodes","abs","svgClass","getAttribute","includes","updateSvgLabels","textContent","adjustTextPosition","middlex","middley","parseInt","svgTextEl","linex","liney","textWidth","getBBox","width","style","stroke","points","newCoordinates","drawInfiniteLine","parentNode","infiniteLine","xMin","yMin","xMax","yMax","slope","intercept","startcoordinates","endcoordinates","ratio","startcoordinatesbits","endcoordinatesbits","parseFloat","whichHandle","maxX","maxY","moveDrags","addToDropZone","eventType","selectedElement","svgDropZones","svgDragsHome","dropX","dropY","whichSVG","classattributes","dropzoneNo","dropZone","isInsideSVG","replace","rect","getBoundingClientRect","left","right","top","bottom","edit","handleIndex","limit","min","getHandlePositions","moveHandles","editHandles","normalizeShape","make","linecoordinates","labels","linestartbits","lineendbits","getSimilar","line"],"mappings":"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"}