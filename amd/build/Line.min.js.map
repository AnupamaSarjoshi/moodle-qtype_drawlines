{"version":3,"file":"Line.min.js","sources":["../src/Line.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/* eslint max-depth: [\"error\", 8] */\n\n/**\n * Library of classes for handling simple shapes.\n *\n * These classes can represent shapes, let you alter them, can go to and from a string\n * representation, and can give you an SVG representation.\n *\n * @module qtype_drawlines/drawLine\n * @copyright  2018 The Open University\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine(function() {\n\n    \"use strict\";\n\n    /**\n     * A point, with x and y coordinates.\n     *\n     * @param {int} x centre X.\n     * @param {int} y centre Y.\n     * @constructor\n     */\n    function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Standard toString method.\n     * @returns {string} \"x;y\";\n     */\n    Point.prototype.toString = function() {\n        return this.x + ',' + this.y;\n    };\n\n    /**\n     * Move a point\n     * @param {int} dx x offset\n     * @param {int} dy y offset\n     */\n    Point.prototype.move = function(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n    };\n\n    /**\n     * Return a new point that is a certain position relative to this one.\n     *\n     * @param {(int|Point)} offsetX if a point, offset by this points coordinates, else and int x offset.\n     * @param {int} [offsetY] used if offsetX is an int, the corresponding y offset.\n     * @return {Point} the new point.\n     */\n    Point.prototype.offset = function(offsetX, offsetY) {\n        if (offsetX instanceof Point) {\n            offsetY = offsetX.y;\n            offsetX = offsetX.x;\n        }\n        return new Point(this.x + offsetX, this.y + offsetY);\n    };\n\n    /**\n     * Make a point from the string representation.\n     *\n     * @param {String} coordinates \"x,y\".\n     * @return {Point} the point. Throws an exception if input is not valid.\n     */\n    Point.parse = function(coordinates) {\n        var bits = coordinates.split(',');\n        if (bits.length !== 2) {\n            throw new Error(coordinates + ' is not a valid point');\n        }\n        return new Point(Math.round(bits[0]), Math.round(bits[1]));\n    };\n\n    /**\n     * Line constructor. Class to represent the different types of drop zone shapes.\n     *\n     * @param {String} [labelstart] start label of a line.\n     * @param {int} [x1] centre X1.\n     * @param {int} [y1] centre Y1.\n     * @param {int} [startRadius] startRadius.\n     * @param {String} [labelend] end label of a line.\n     * @param {int} [x2] centre X2.\n     * @param {int} [y2] centre Y2.\n     * @param {int} [endRadius] endRadius.\n     * @param {String} [lineType] Line type.\n     * @constructor\n     */\n    function Line(labelstart, x1, y1, startRadius, labelend, x2, y2, endRadius, lineType) {\n        this.labelstart = labelstart;\n        this.labelend = labelend;\n        this.x1 = x1 || 15;\n        this.y1 = y1 || 100;\n\n        this.x2 = x2 || 200;\n        this.y2 = y2 || 250;\n\n        this.centre1 = new Point(x1 || 0, y1 || 0);\n        this.centre2 = new Point(x2 || 0, y2 || 0);\n\n        this.startRadius = startRadius;\n        this.endRadius = endRadius;\n\n        this.lineType = lineType;\n    }\n    Line.prototype = new Line();\n\n\n    /**\n     * Get the type of shape.\n     *\n     * @return {String} 'linesinglearrow', 'linedoublearrows', 'lineinfinite'.\n     */\n    Line.prototype.getType = function() {\n        return this.lineType;\n    };\n\n    /**\n     * Get the string representation of this shape.\n     *\n     * @return {String} coordinates as they need to be typed into the form.\n     */\n    Line.prototype.getCoordinates = function() {\n        return [\n            this.centre1.x + ',' + this.centre1.y + ';' + this.startRadius,\n            this.centre2.x + ',' + this.centre2.y + ';' + this.endRadius\n        ];\n    };\n\n    /**\n     * Create the svg group with line.\n     *\n     * @param {SVGElement} svg the SVG graphic to add this shape to.\n     * @return {SVGElement} SVG representation of this shape.\n     */\n    Line.prototype.makeSvg = function(svg) {\n        addLineArrow(svg);\n        var svgEl = createSvgShapeGroup(svg, 'polyline');\n        this.updateSvg(svgEl);\n        return svgEl;\n    };\n\n    /**\n     * Update the SVG representation of this shape.\n     *\n     * @param {SVGElement} svgEl the SVG representation of this shape.\n     */\n    Line.prototype.updateSvg = function(svgEl) {\n\n        // Set line attributes.\n        this.drawLine(svgEl);\n\n        // Set start and end circle attributes.\n        svgEl.childNodes[1].setAttribute('cx', this.centre1.x);\n        svgEl.childNodes[1].setAttribute('cy', this.centre1.y);\n        svgEl.childNodes[1].setAttribute('r', Math.abs(this.startRadius));\n\n        svgEl.childNodes[2].setAttribute('cx', this.centre2.x);\n        svgEl.childNodes[2].setAttribute('cy', this.centre2.y);\n        svgEl.childNodes[2].setAttribute('r', Math.abs(this.endRadius));\n\n        // Set start and end label attributes.\n        svgEl.childNodes[3].textContent = this.labelstart;\n        svgEl.childNodes[3].setAttribute('x', this.centre1.x);\n        svgEl.childNodes[3].setAttribute('y', parseInt(this.centre1.y) + 20);\n\n        svgEl.childNodes[4].textContent = this.labelend;\n        svgEl.childNodes[4].setAttribute('x', this.centre2.x);\n        svgEl.childNodes[4].setAttribute('y', parseInt(this.centre2.y) + 20);\n    };\n\n    /**\n     * Update svg line attributes.\n     *\n     * @param {SVGElement} svgEl the SVG representation of the shape.\n     */\n    Line.prototype.drawLine = function(svgEl) {\n        // Set attributes for the polyline.\n        svgEl.childNodes[0].style.stroke = \"#000973\";\n        svgEl.childNodes[0].style['stroke-width'] = \"3\";\n        svgEl.childNodes[0].style['stroke-dasharray'] = \"10,3\";\n\n        var points = this.centre1.x + \",\" + this.centre1.y + \" \" + this.centre2.x + \",\" + this.centre2.y;\n        svgEl.childNodes[0].setAttribute('points', points);\n\n        // Set attributes to display line based on linetype.\n        switch (this.lineType) {\n            case 'linesinglearrow':\n                svgEl.childNodes[0].style['marker-end'] = \"url(#arrow)\";\n                break;\n\n            case 'linedoublearrows':\n                svgEl.childNodes[0].style['marker-start'] = \"url(#arrow)\";\n                svgEl.childNodes[0].style['marker-end'] = \"url(#arrow)\";\n                break;\n\n            case 'lineinfinite':\n                var newCoordinates = this.drawInfiniteLine(svgEl.parentNode);\n                var infiniteLine = newCoordinates[0] + \",\" + newCoordinates[1] +\n                    \" \" + points + \" \" + newCoordinates[2] + \",\" + newCoordinates[3];\n                svgEl.childNodes[0].setAttribute('points', infiniteLine);\n                break;\n        }\n    };\n\n    /**\n     * Get the minimum and maximum endpoints of the line to draw an infinite line.\n     *\n     * @param {SVGElement} svg the SVG representation of the shape.\n     */\n    Line.prototype.drawInfiniteLine = function(svg) {\n\n        const width = svg.width.baseVal.value;\n        const height = svg.height.baseVal.value;\n\n        // Calculate slope\n        const dx = this.centre2.x - this.centre1.x;\n        const dy = this.centre2.y - this.centre1.y;\n\n        // Calculate points far outside the SVG canvas\n        let xMin, yMin, xMax, yMax;\n        if (dx === 0) { // Vertical line\n            xMin = xMax = this.centre1.x;\n            yMin = 0;\n            yMax = height;\n        } else if (dy === 0) { // Horizontal line\n            xMin = 0;\n            xMax = width;\n            yMin = yMax = this.centre1.y;\n        } else {\n            const slope = dy / dx;\n            const intercept = this.centre1.y - slope * this.centre1.x;\n\n            // Find intersection points with SVG canvas borders\n            xMin = -width; // Starting far left\n            yMin = slope * xMin + intercept;\n\n            xMax = 2 * width; // Extending far right\n            yMax = slope * xMax + intercept;\n\n            // Clamp to canvas height bounds\n            if (yMin < 0) {\n                yMin = 0;\n                xMin = (yMin - intercept) / slope;\n            } else if (yMin > height) {\n                yMin = height;\n                xMin = (yMin - intercept) / slope;\n            }\n\n            if (yMax < 0) {\n                yMax = 0;\n                xMax = (yMax - intercept) / slope;\n            } else if (yMax > height) {\n                yMax = height;\n                xMax = (yMax - intercept) / slope;\n            }\n        }\n        return [Math.round(xMin), Math.round(yMin), Math.round(xMax), Math.round(yMax)];\n\n    };\n\n    /**\n     * Parse the coordinates from the string representation.\n     *\n     * @param {String} startcoordinates \"x1,y1\".\n     * @param {String} endcoordinates \"x1,y1\".\n     * @param {float} ratio .\n     * @return {Point} the point. Throws an exception if input is not valid.\n     */\n    Line.prototype.parse = function(startcoordinates, endcoordinates, ratio) {\n        var startcoordinatesbits = startcoordinates.split(';');\n        var endcoordinatesbits = endcoordinates.split(';');\n        this.centre1 = Point.parse(startcoordinatesbits[0]);\n        this.centre2 = Point.parse(endcoordinatesbits[0]);\n        this.centre1.x = this.centre1.x * parseFloat(ratio);\n        this.centre1.y = this.centre1.y * parseFloat(ratio);\n        this.x1 = this.centre1.x * parseFloat(ratio);\n        this.y1 = this.centre1.y * parseFloat(ratio);\n        this.x2 = this.centre2.x * parseFloat(ratio);\n        this.y2 = this.centre2.y * parseFloat(ratio);\n        this.centre2.x = this.centre2.x * parseFloat(ratio);\n        this.centre2.y = this.centre2.y * parseFloat(ratio);\n        this.startRadius = Math.round(startcoordinatesbits[1]) * parseFloat(ratio);\n        this.endRadius = Math.round(endcoordinatesbits[1]) * parseFloat(ratio);\n\n        return true;\n    };\n\n    /**\n     * Move the entire shape by this offset.\n     *\n     * @param {String} handleIndex which handle was moved.\n     * @param {int} dx x offset.\n     * @param {int} dy y offset.\n     * @param {int} maxX ensure that after editing, the shape lies between 0 and maxX on the x-axis.\n     * @param {int} maxY ensure that after editing, the shape lies between 0 and maxX on the y-axis.\n     */\n    Line.prototype.move = function(handleIndex, dx, dy, maxX, maxY) {\n        if (handleIndex === '0') {\n            this.centre1.move(dx, dy);\n            if (this.centre1.x < this.startRadius) {\n                this.centre1.x = this.startRadius;\n                this.x1 = this.startRadius;\n            }\n            if (this.centre1.x > maxX - this.startRadius) {\n                this.centre1.x = maxX - this.startRadius;\n                this.x1 = maxX - this.startRadius;\n            }\n            if (this.centre1.y < this.endRadius) {\n                this.centre1.y = this.endRadius;\n                this.y1 = this.endRadius;\n            }\n            if (this.centre1.y > maxY - this.endRadius) {\n                this.centre1.y = maxY - this.endRadius;\n                this.y1 = maxY - this.endRadius;\n            }\n        } else {\n            this.centre2.move(dx, dy);\n            if (this.centre2.x < this.startRadius) {\n                this.centre2.x = this.startRadius;\n                this.x2 = this.startRadius;\n            }\n            if (this.centre2.x > maxX - this.startRadius) {\n                this.centre2.x = maxX - this.startRadius;\n                this.x2 = maxX - this.startRadius;\n            }\n            if (this.centre2.y < this.endRadius) {\n                this.centre2.y = this.endRadius;\n                this.y2 = this.endRadius;\n            }\n            if (this.centre2.y > maxY - this.endRadius) {\n                this.centre2.y = maxY - this.endRadius;\n                this.y2 = maxY - this.endRadius;\n            }\n        }\n    };\n\n    /**\n     * Move the entire line by this offset.\n     *\n     * @param {int} dx x offset.\n     * @param {int} dy y offset.\n     * @param {int} maxX ensure that after editing, the shape lies between 0 and maxX on the x-axis.\n     * @param {int} maxY ensure that after editing, the shape lies between 0 and maxX on the y-axis.\n     * @param {String} whichSVG The svg containing the drag.\n     */\n    Line.prototype.moveDrags = function(dx, dy, maxX, maxY, whichSVG) {\n        // If the drags are in the dragHomes then we want to keep the x coordinates fixed.\n        if (whichSVG === 'DragsSVG') {\n            // We don't want to move drags horizontally in this SVG.\n            this.centre1.move(0, dy);\n            this.centre2.move(0, dy);\n            this.centre1.x = 50;\n            this.x1 = 50;\n            this.centre2.x = 200;\n            this.x2 = 200;\n        } else {\n            this.centre1.move(dx, dy);\n            this.centre2.move(dx, dy);\n            if (this.centre1.x < this.startRadius) {\n                this.centre1.x = this.startRadius;\n                this.x1 = this.startRadius;\n            }\n            if (this.centre1.x > maxX - this.startRadius) {\n                this.centre1.x = maxX - this.startRadius;\n                this.x1 = maxX - this.startRadius;\n            }\n            if (this.centre2.x < this.startRadius) {\n                this.centre2.x = this.startRadius;\n                this.x2 = this.startRadius;\n            }\n            if (this.centre2.x > maxX - this.startRadius) {\n                this.centre2.x = maxX - this.startRadius;\n                this.x2 = maxX - this.startRadius;\n            }\n        }\n        if (this.centre1.y < this.endRadius) {\n            this.centre1.y = this.endRadius;\n            this.y1 = this.endRadius;\n        }\n        if (this.centre1.y > maxY - this.endRadius) {\n            this.centre1.y = maxY - this.endRadius;\n            this.y1 = maxY - this.endRadius;\n        }\n        if (this.centre2.y < this.endRadius) {\n            this.centre2.y = this.endRadius;\n            this.y2 = this.endRadius;\n        }\n        if (this.centre2.y > maxY - this.endRadius) {\n            this.centre2.y = maxY - this.endRadius;\n            this.y2 = maxY - this.endRadius;\n        }\n    };\n\n    /**\n     * Move the g element between the dropzones and dragHomes.\n     * @param {SVGElement} svgDrags Svg element containing the drags.\n     * @param {SVGElement} svgDropZones Svg element containing the dropZone.\n     * @param {SVGElement} selectedElement The element selected for dragging.\n     * @param {int} dropX\n     * @param {int} dropY\n     */\n    Line.prototype.addToDropZone = function(svgDrags, svgDropZones, selectedElement, dropX, dropY) {\n        var maxY = 0;\n        var dropzoneNo = selectedElement.getAttribute('data-dropzone-no');\n\n        if (this.isInsideSVG(svgDrags, dropX, dropY)) {\n            // Append the element to the second SVG\n            // Get the height of the dropZone SVG.\n            maxY = svgDropZones.height.baseVal.value;\n            svgDropZones.appendChild(selectedElement);\n            selectedElement.getAttribute('data-dropzone-no');\n\n            // Caluculate the position of line drop.\n            // this.centre1.y = maxY - (2 * this.startRadius) - (dropzoneNo * 50);\n            // this.y1 = maxY - (2 * this.startRadius) - (dropzoneNo * 50);\n            // this.centre2.y = maxY - (2 * this.endRadius) - (dropzoneNo * 50);\n            // this.y2 = maxY - (2 * this.endRadius) - (dropzoneNo * 50);\n            this.centre1.y = maxY - (2 * this.startRadius);\n            this.y1 = maxY - (2 * this.startRadius);\n            this.centre2.y = maxY - (2 * this.endRadius);\n            this.y2 = maxY - (2 * this.endRadius);\n        } else if (this.isInsideSVG(svgDropZones, dropX, dropY)) {\n            // Append the element to the first SVG (to ensure it stays in the same SVG if dropped there)\n            svgDrags.appendChild(selectedElement);\n\n            // We want to drop the lines from the top, depending on the line number.\n            // Calculate the position of line drop.\n            this.centre1.x = 50;\n            this.centre1.y = this.startRadius + (dropzoneNo * 50);\n            this.y1 = this.startRadius + (dropzoneNo * 50);\n            this.centre2.x = 200;\n            this.centre2.y = this.endRadius + (dropzoneNo * 50);\n            this.y2 = this.endRadius + (dropzoneNo * 50);\n        }\n    };\n\n    /**\n     * Check if the current selected element is in the svg .\n     * @param {SVGElement} svg Svg element containing the drags.\n     * @param {int} dropX\n     * @param {int} dropY\n     * @return {bool}\n     */\n    Line.prototype.isInsideSVG = function(svg, dropX, dropY){\n        const rect = svg.getBoundingClientRect();\n        return dropX >= rect.left && dropX <= rect.right && dropY >= rect.top && dropY <= rect.bottom;\n    };\n\n    /**\n     * Move one of the edit handles by this offset.\n     *\n     * @param {String} handleIndex which handle was moved.\n     * @param {int} dx x offset.\n     * @param {int} dy y offset.\n     * @param {int} maxX ensure that after editing, the shape lies between 0 and maxX on the x-axis.\n     * @param {int} maxY ensure that after editing, the shape lies between 0 and maxX on the y-axis.\n     */\n    Line.prototype.edit = function(handleIndex, dx, dy, maxX, maxY) {\n        var limit = 0;\n        if (handleIndex === '0') {\n            this.startRadius += dx;\n            limit = Math.min(this.centre1.x, this.centre1.y, maxX - this.centre1.x, maxY - this.centre1.y);\n            if (this.startRadius > limit) {\n                this.startRadius = limit;\n            }\n            if (this.startRadius < -limit) {\n                this.startRadius = -limit;\n            }\n        } else {\n            this.endRadius += dx;\n            limit = Math.min(this.centre2.x, this.centre2.y, maxX - this.centre2.x, maxY - this.centre2.y);\n            if (this.endRadius > limit) {\n                this.endRadius = limit;\n            }\n            if (this.endRadius < -limit) {\n                this.endRadius = -limit;\n            }\n        }\n    };\n\n    /**\n     * Get the handles that should be offered to edit this shape, or null if not appropriate.\n     *\n     * @return {Object[]} with properties moveHandleStart {Point}, moveHandleEnd {Point} and editHandles {Point[]}.\n     */\n    Line.prototype.getHandlePositions = function() {\n        return {\n            moveHandles: [new Point(this.centre1.x, this.centre1.y), new Point(this.centre2.x, this.centre2.y)],\n            editHandles: [this.centre1.offset(this.startRadius, 0), this.centre2.offset(this.endRadius, 0)]\n        };\n    };\n\n    /**\n     * Update the properties of this shape after a sequence of edits.\n     *\n     * For example make sure the circle radius is positive, of the polygon centre is centred.\n     */\n    Line.prototype.normalizeShape = function() {\n        this.startRadius = Math.abs(this.startRadius);\n        this.endRadius = Math.abs(this.endRadius);\n    };\n\n    /**\n     * Add a new arrow SVG DOM element as a child of svg.\n     *\n     * @param {SVGElement} svg the parent node.\n     * @return {SVGElement} the newly created node.\n     */\n     function addLineArrow(svg) {\n        if (svg.getElementsByTagName('defs')[0]) {\n            return;\n        }\n        var svgdefsEl = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'defs');\n        var svgmarkerEl = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'marker');\n        svgmarkerEl.setAttribute('id', 'arrow');\n        svgmarkerEl.setAttribute('viewBox', \"0 0 10 10\");\n        svgmarkerEl.setAttribute('refX', '7');\n        svgmarkerEl.setAttribute('refY', '5');\n        svgmarkerEl.setAttribute('markerWidth', '4');\n        svgmarkerEl.setAttribute('markerHeight', '4');\n        svgmarkerEl.setAttribute('orient', 'auto-start-reverse');\n        var svgPathEl = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');\n        svgPathEl.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n        svgmarkerEl.appendChild(svgPathEl);\n        svgdefsEl.appendChild(svgmarkerEl);\n\n        svg.appendChild(svgdefsEl);\n    }\n\n    /**\n     * Make a new SVG DOM element as a child of svg.\n     *\n     * @param {SVGElement} svg the parent node.\n     * @param {String} tagName the tag name.\n     * @return {SVGElement} the newly created node.\n     */\n    function createSvgElement(svg, tagName) {\n        var svgEl = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', tagName);\n        svg.appendChild(svgEl);\n        return svgEl;\n    }\n\n    /**\n     * Make a group SVG DOM elements containing a polyline of the given linetype as first child,\n     * two circles to mark the allowed radius for grading and text labels for the line.\n     *\n     * @param {SVGElement} svg the parent node.\n     * @param {String} tagName the tag name.\n     * @return {SVGElement} the newly created g element.\n     */\n    function createSvgShapeGroup(svg, tagName) {\n        var svgEl = createSvgElement(svg, 'g');\n        createSvgElement(svgEl, tagName).setAttribute('class', 'shape');\n        createSvgElement(svgEl, 'circle').setAttribute('class', 'startcircle shape');\n        createSvgElement(svgEl, 'circle').setAttribute('class', 'endcircle shape');\n        createSvgElement(svgEl, 'text').setAttribute('class', 'labelstart shapeLabel');\n        createSvgElement(svgEl, 'text').setAttribute('class', 'labelend shapeLabel');\n        return svgEl;\n    }\n\n    /**\n     * @alias module:qtype_drawlines/drawLine\n     */\n    return {\n        /**\n         * A point, with x and y coordinates.\n         *\n         * @param {int} x centre X.\n         * @param {int} y centre Y.\n         * @constructor\n         */\n        Point: Point,\n\n        /**\n         * Line constructor. Class to represent the different types of drop zone shapes.\n         *\n         * @param {String} [labelstart] start label of a line.\n         * @param {int} [x1] centre X1.\n         * @param {int} [y1] centre Y1.\n         * @param {int} [startRadius] startRadius.\n         * @param {String} [labelend] end label of a line.\n         * @param {int} [x2] centre X2.\n         * @param {int} [y2] centre Y2.\n         * @param {int} [endRadius] endRadius.\n         * @param {String} [lineType] Line type.\n         * @constructor\n         */\n        Line: Line,\n\n        /**\n         * Make a new SVG DOM element as a child of svg.\n         *\n         * @param {SVGElement} svg the parent node.\n         * @param {String} tagName the tag name.\n         * @return {SVGElement} the newly created node.\n         */\n        createSvgElement: createSvgElement,\n\n        /**\n         * Make a line of the given type.\n         *\n         * @param {Array} linecoordinates in the format (x,y;radius).\n         * @param {Array} labels Start and end labels of a line.\n         * @param {String} lineType The linetype (e.g., linesinglearrow, linedoublearrows, ...).\n         * @return {Line} the new line.\n         */\n        make: function(linecoordinates, labels, lineType) {\n            // Line coordinates are in the format (x,y;radius).\n            var startcoordinates = linecoordinates[0].split(';');\n            var endcoordinates = linecoordinates[1].split(';');\n            var linestartbits = startcoordinates[0].split(',');\n            var lineendbits = endcoordinates[0].split(',');\n\n            return new Line(labels[0], linestartbits[0], linestartbits[1], startcoordinates[1], labels[1],\n                lineendbits[0], lineendbits[1], endcoordinates[1], lineType);\n        },\n\n        /**\n         * Make a line of the given linetype having similar coordinates and labels as the original type.\n         *\n         * @param {String} lineType the new type of line to make.\n         * @param {line} line the line to copy.\n         * @return {line} the similar line of a different linetype.\n         */\n        getSimilar: function(lineType, line) {\n            return new Line(line.labelstart, parseInt(line.x1), parseInt(line.y1), parseInt(line.startRadius),\n                parseInt(line.labelend), parseInt(line.x2), parseInt(line.y2), parseInt(line.endRadius), lineType);\n        }\n    };\n});\n"],"names":["define","Point","x","y","Line","labelstart","x1","y1","startRadius","labelend","x2","y2","endRadius","lineType","centre1","centre2","createSvgElement","svg","tagName","svgEl","ownerDocument","createElementNS","appendChild","prototype","toString","this","move","dx","dy","offset","offsetX","offsetY","parse","coordinates","bits","split","length","Error","Math","round","getType","getCoordinates","makeSvg","getElementsByTagName","svgdefsEl","svgmarkerEl","setAttribute","svgPathEl","addLineArrow","createSvgShapeGroup","updateSvg","drawLine","childNodes","abs","textContent","parseInt","style","stroke","points","newCoordinates","drawInfiniteLine","parentNode","infiniteLine","width","baseVal","value","height","xMin","yMin","xMax","yMax","slope","intercept","startcoordinates","endcoordinates","ratio","startcoordinatesbits","endcoordinatesbits","parseFloat","handleIndex","maxX","maxY","moveDrags","whichSVG","addToDropZone","svgDrags","svgDropZones","selectedElement","dropX","dropY","dropzoneNo","getAttribute","isInsideSVG","rect","getBoundingClientRect","left","right","top","bottom","edit","limit","min","getHandlePositions","moveHandles","editHandles","normalizeShape","make","linecoordinates","labels","linestartbits","lineendbits","getSimilar","line"],"mappings":"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"}